#define _CRT_SECURE_NO_WARNINGS 1
#include<string.h>
#include<stdlib.h>

/******************************************************************************************
 * Text : 0   1   2   .   .   .   i-j  .   .   .   .   i   .   .   n-1  
 *        ------------------------|--------------------|------------
 * Pattern :                      0    .   .   .   .   j   .   .
 *                                |--------------------|
******************************************************************************************/
//串匹配算法（Brute-force-1）
int match1(char* P, char* T)
{
	size_t n = strlen(T), i = 0;//文本串长度、当前接受比对字符的位置
	size_t m = strlen(P), j = 0;//模式串长度、当前接受比对字符的位置
	while (j < m && i < n)//自左向右逐个比对字符，直到i越界或j越界
	{
		if (T[i] == P[j])//若匹配
		{
			//则转到下一对字符
			++i;
			++j;
		}
		else
		{
			i -= j - 1;//文本串回退并前进 1 位
			j = 0;//模式串复位
		}
	}
	//若匹配成功，则为j越界，i-j <= n-m
	//若匹配失败，则为i越界, i-j > n-m 
	return i - j;
}


/******************************************************************************************
* Text : 0   1   2   .   .   .   i    i+1 .   .   .   i+j .   .   n-1
*        ------------------------|--------------------|------------
* Pattern :                      0    1   .   .   .   j   .   .
*                                |--------------------|
******************************************************************************************/
//串匹配算法(Brute-force-2)
int match2(char* P, char* T)
{
	size_t n = strlen(T), i = 0;//文本串长度，与模式串首字符的对齐位置
	size_t m = strlen(P), j;//模式串长度，当前接受比对字符的位置
	for (i = 0; i < n - m + 1; ++i)
	{//文本串从第i个字符开始，与
		for (j = 0; j < m; ++j)
		{//模式串中对应的字符逐个比对
			if (T[i + j] != P[j])
				break;//若失配，模式串整体右移一个字符，再做一轮比对
		}
		if (j >= m)
			break;//找到匹配子串
	}
	//若匹配失败，则i越界，	  i >  n-m
	//若匹配成功，则i尚未越界 i <= n-m
	return i;
}





//构造模式串P的next表
int* buildNext(char* P)
{
	size_t m = strlen(P), j = 0;//“主”串指针
	int* N = new int[m];//next表
	int t = N[0] = -1;//模式串指针
	while (j < m - 1)
	{
		if (0 > t || P[j] == P[t])//匹配
		{
			++j; ++t;
			//N[j] = t;//此句可改进
			N[j] = (P[j] != P[t] ? t : N[t]);//改进后，若P[j] == P[t]，将赋予next[t],即上个next表项，用于跳过匹配的当前字符对
		}
		else//失配,最终终止于N[0] = -1
			t = N[t];//尽量少地回退，反复回到上一next匹配，即next[next[t]]
	}
	return N;
}

//KMP算法待改进版
int matchKMP1(char* P, char* T)
{
	int* next = buildNext(P);//构造next表
	int n = (int)strlen(T), i = 0;//文本串指针
	int m = (int)strlen(P), j = 0;//模式串指针
	while ( j < m && i < n )//自左向右逐个比对字符
	{
		if (0 > j || T[i] == P[j])//若P已移出最左侧，或匹配（两个判断的次序不可交换）
		{
			++i;//则转到下一字符
			++j;
		}
		else//否则
			j = next[j];//模式串右移（注意：文本串不用回退）
	}
	delete[] next;//释放next表
	return i - j;
}




//*****************************************************************************************
//		0						bc['X']								   m-1 
//		|						|									   | 
//		........................X***************************************
//							    .|<------------- 'X' free ------------>|
//*****************************************************************************************
//构造Bad Charactor Shift表:  O(m + 256)
int* buildBC(char* P)
{
	int* bc = new int[256];//BC表，与字符表等长
	for (size_t j = 0; j < 256; ++j)//初始化：首先假设所有字符均未在P中出现
		bc[j] = -1;
	for (size_t m = strlen(P), j = 0; j < m; ++j)//自左向右扫描模式串P
		bc[P[j]] = j;//将字符P[j]的BC项更新为j( 单调递增 )――画家算法
	return bc;
}

int* buildGS(char* P)
{

}

//Boyer-Morre算法（完全版，兼顾Bad Character 与 Good Suffix）
int matchBM(char* P, char* T)
{
	int* bc = buildBC(P); int* gs = buildGS(P);//构造BC表和GS表
	size_t i = 0;//模式串相对于文本串的起始位置（初始时与文本串左对齐）
	while (strlen(T) >= i + strlen(P))//不断右移（距离可能不止一个字符）模式串
	{
		int j = strlen(P) - 1;//从模式串最末尾的字符开始
		while (P[j] == T[i+j])//自右向左比对,失配时停止本次匹配
			if (0 > --j)//越界时也停止本次匹配
				break;
		if (0 > j)//若极大匹配后缀 == 整个模式串（说明已经完全匹配）
			break;//返回匹配位置
		else//否则，适当地移动模式串
			i += __max(gs[j], j - bc[T[i + j]]);//位移量根据BC表和GS表选择最大者
	}
	delete[] gs; delete[] bc;//销毁GS表和BC表
	return i;
}